Events.PlayerMeleeActionCallback m_playerMeleeActionEvent = null;
Events.UserMessageCallback m_userMessageCallback = null;

const string    AcidSplash = "ACS";
const string    Block = "Block";
const string    Blood = "BLD";
const string    BloodTrail = "TR_B";
const string    BulletHit = "BulletHit";
const string    BulletHitCloth = "BulletHitCloth";
const string    BulletHitDefault = "BulletHitDefault";
const string    BulletHitDirt = "BulletHitDirt";
const string    BulletHitMetal = "BulletHitMetal";
const string    BulletHitMoney = "BulletHitMoney";
const string    BulletHitPaper = "BulletHitPaper";
const string    BulletHitWood = "BulletHitWood";
const string    ChainsawSmoke = "CSW";
const string    ClothHit = "CL_H";
const string    CloudDissolve = "DISS";
const string    DestroyCloth = "DestroyCloth";
const string    DestroyDefault = "DestroyDefault";
const string    DestroyGlass = "DestroyGlass";
const string    DestroyMetal = "DestroyMetal";
const string    DestroyPaper = "DestroyPaper";
const string    DestroyWood = "DestroyWood";
const string    Dig = "DIG";
const string    DustTrail = "TR_D";
const string    Electric = "Electric";
const string    Explosion = "EXP";
const string    Fire = "FIRE";
const string    FireNodeTrailAir = "FNDTRA";
const string    FireNodeTrailGround = "FNDTRG";
const string    FireTrail = "TR_F";
const string    Gib = "GIB";
const string    GlassParticles = "G_P";
const string    GrenadeDud = "GR_D";
const string    ImpactDefault = "ImpactDefault";
const string    ImpactPaper = "ImpactPaper";
const string    ItemGleam = "GLM";
const string    MeleeHitBlunt = "HIT_B";
const string    MeleeHitSharp = "HIT_S";
const string    MeleeHitUnarmed = "HIT_U";
const string    PaperDestroyed = "PPR_D";
const string    PlayerBurned = "PLRB";
const string    PlayerFootstep = "F_S";
const string    PlayerLandFull = "H_T";
const string    Smack = "Smack";
const string    SmokeTrail = "TR_S";
const string    Sparks = "S_P";
const string    Steam = "STM";
const string    WaterSplash = "WS";
const string    WoodParticles = "W_P";

string particle = "FIRE";
Vector2 areaOffset = new Vector2(20, 0);

float escalar = 2.0f;

//We use this to get the points in a line
//https://stackoverflow.com/a/34142336/11490425
public class Line {
	public Vector2 p1, p2;

	public Line(Vector2 p1, Vector2 p2) {
		this.p1 = p1;
		this.p2 = p2;
	}

	//this will return a Point array of "quantity" points evenly spaced between the two endpoints (inclusive). 
	public Vector2[] getPoints(ushort quantity) {
		var points = new Vector2[quantity];
		float ydiff = p2.Y - p1.Y, xdiff = p2.X - p1.X;
		double slope = (double)(p2.Y - p1.Y) / (p2.X - p1.X);
		double x, y;

		--quantity;

		for (double i = 0; i < quantity; i++) {
			y = slope == 0 ? 0 : ydiff * (i / quantity);
			x = slope == 0 ? xdiff * (i / quantity) : y / slope;
			points[(int)i] = new Vector2((int)Math.Round(x) + p1.X, (int)Math.Round(y) + p1.Y);
		}

		points[quantity] = p2;
		return points;
	}
}


//propierties
List<List<Line>> groupsListMatrix = new List<List<Line>>();
List<Vector2> pointsList = new List<Vector2>();
int pointTracker = -1;
bool allLinesHaveBeenAdded = false;

//methods
public void Animate(TriggerArgs args){
	if (pointsList.Count == 0 && allLinesHaveBeenAdded) {
		//This is the first run of Animate
		//Calculate all points from the lineList and add them into pointsList

		for(ushort groupCounter = 0; groupCounter < groupsListMatrix.Count; groupCounter++){
			List<List<Vector2>> middlemanMatrix = new List<List<Vector2>>();
			
			for(ushort lineCounter = 0; lineCounter < groupsListMatrix[groupCounter].Count; lineCounter++){
				Vector2[] points = groupsListMatrix[groupCounter][lineCounter].getPoints(10);
				middlemanMatrix.Add(new List<Vector2>());
				
				for(ushort pointCounter = 0; pointCounter < points.Length; pointCounter++){
					middlemanMatrix[lineCounter].Add(points[pointCounter]);
				}
			}
			//transpose middlemanMatrix
			List<List<Vector2>> transposedMiddlemanMatrix = Transpose(middlemanMatrix);

			//Add the points to pointsList
			for(ushort column = 0; column < transposedMiddlemanMatrix.Count; column++){
				for(ushort row = 0; row < transposedMiddlemanMatrix[column].Count; row++){
					pointsList.Add(transposedMiddlemanMatrix[column][row]);
				}
			}

		}

		

		//Reset the point tracker
		pointTracker=-1;
	}

	pointTracker++;
	
	if(pointTracker >= pointsList.Count){
		//Clear the counters
		groupsListMatrix = new List<List<Line>>();
		pointsList = new List<Vector2>();
		pointTracker = -1;
	} else {
		Game.PlayEffect(particle, pointsList[pointTracker]);
	}


}


//This function transposes a List<List<Vector2>> matrix
//https://stackoverflow.com/a/13586633/11490425
public static List<List<Vector2>> Transpose<Vector2>(List<List<Vector2>> lists){
	var longest = lists.Any() ? lists.Max(l => l.Count) : 0;
	List<List<Vector2>> outer = new List<List<Vector2>>(longest);
	for (int i = 0; i < longest; i++)
		outer.Add(new List<Vector2>(lists.Count));
	for (int j = 0; j < lists.Count; j++)
		for (int i = 0; i < longest; i++)
			outer[i].Add(lists[j][i]);
	return outer;
}


public void OnStartup() {
	m_playerMeleeActionEvent = Events.PlayerMeleeActionCallback.Start(OnPlayerMeleeAction);
	m_userMessageCallback = Events.UserMessageCallback.Start(OnUserMessage);
}

public void OnPlayerMeleeAction(IPlayer plr, PlayerMeleeHitArg[] args) {
	//Punch + ALT
	if(plr.IsMeleeAttacking == true & plr.IsWalking == true){
		Vector2 plrpos = plr.GetWorldPosition();

		//simple middle points
		Vector2 upperMiddle = new Vector2(0f * escalar, 31f * escalar);
		Vector2 rightMiddle = new Vector2(26.8f * escalar, -15f * escalar);
		Vector2 leftMiddle  = new Vector2(-26.8f * escalar, -15f * escalar);

		//corners
		Vector2 rightCorner = new Vector2(53f * escalar, 31f * escalar);
		Vector2 lowerCorner = new Vector2(0f * escalar, -60.5f * escalar);
		Vector2 leftCorner  = new Vector2(-53f * escalar, 31f * escalar);
		
		//Inner middle points
		Vector2 upperRightMiddle = new Vector2(26.8f * escalar, 16f * escalar);
		Vector2 lowerMiddle      = new Vector2(0f * escalar, -30.5f * escalar);
		Vector2 upperLeftMiddle  = new Vector2(-26.8f * escalar, 16f * escalar);

		//Draw the funky triangle
		//First three lines
		//We use an empty offset on these lines because they come from the player direct's location
		groupsListMatrix.Add(new List<Line>(){
			calculateLine(plrpos, new Vector2(0f, 0f), upperMiddle),
			calculateLine(plrpos, new Vector2(0f, 0f), rightMiddle),
			calculateLine(plrpos, new Vector2(0f, 0f), leftMiddle),
		});

		
		//Border lines
		groupsListMatrix.Add(new List<Line>(){
			calculateLine(plrpos, upperMiddle, rightCorner),
			calculateLine(plrpos, upperMiddle, leftCorner),

			calculateLine(plrpos, rightMiddle, rightCorner),
			calculateLine(plrpos, rightMiddle, lowerCorner),

			calculateLine(plrpos, leftMiddle, lowerCorner),
			calculateLine(plrpos, leftMiddle, leftCorner)
		});

		
		//inner middle lines
		groupsListMatrix.Add(new List<Line>(){
			calculateLine(plrpos, rightCorner, upperRightMiddle),
			calculateLine(plrpos, lowerCorner, lowerMiddle),
			calculateLine(plrpos, leftCorner, upperLeftMiddle),
		});


		//Inner square
		groupsListMatrix.Add(new List<Line>(){
			calculateLine(plrpos, upperMiddle, upperRightMiddle),
			calculateLine(plrpos, upperMiddle, upperLeftMiddle),

			calculateLine(plrpos, rightMiddle, upperRightMiddle),
			calculateLine(plrpos, rightMiddle, lowerMiddle),

			calculateLine(plrpos, leftMiddle, lowerMiddle),
			calculateLine(plrpos, leftMiddle, upperLeftMiddle),
		});
			
		allLinesHaveBeenAdded = true;

		//I use three timers to make the animation faster
		//Formula:
		//1, (totalNumberOfLines/numberOfTimers * 10) + 1, "Animate"
		startTimer(1, (6 * 10) + 1, "Animate");
		startTimer(1, (6 * 10) + 1, "Animate");
		startTimer(1, (6 * 10) + 1, "Animate");
	}
}


public Line calculateLine(Vector2 plrpos, Vector2 startCoordinates, Vector2 endCoordinates){
	
	//create a line between startCoordinates and endCoordinates, using prlpos as the reference point
	Line line = new Line(
		new Vector2(plrpos.X + startCoordinates.X, plrpos.Y + startCoordinates.Y), 
		new Vector2(plrpos.X + endCoordinates.X, plrpos.Y + endCoordinates.Y)
	);

	return line;
}

public void startTimer(int timerSpeed, int skillLength, string functionNameCallback){
	IObjectTimerTrigger timer = (IObjectTimerTrigger)Game.CreateObject("TimerTrigger");
	timer.SetIntervalTime(timerSpeed);
	timer.SetRepeatCount(skillLength);
	timer.SetScriptMethod(functionNameCallback);
	timer.Trigger();
}

public void OnUserMessage(UserMessageCallbackArgs args) {

	if (args.IsCommand){
		string[] a = args.CommandArguments.Split();
		if(args.Command == "P"){
			particle = a[0];
			Game.ShowChatMessage("Effect set to \"" + particle + "\"", Color.Green);
		} 

		if (args.Command == "L") {
			areaOffset.X = (float)Convert.ToInt32(a[0]);
			areaOffset.Y = (float)Convert.ToInt32(a[1]);
			Game.ShowChatMessage("Offset set to \"" + areaOffset.X + " " + areaOffset.Y + "\"", Color.Green);
		}

	}
}