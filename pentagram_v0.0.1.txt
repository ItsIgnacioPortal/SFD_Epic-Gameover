Events.PlayerMeleeActionCallback m_playerMeleeActionEvent = null;
Events.UserMessageCallback m_userMessageCallback = null;

const string    AcidSplash = "ACS";
const string    Block = "Block";
const string    Blood = "BLD";
const string    BloodTrail = "TR_B";
const string    BulletHit = "BulletHit";
const string    BulletHitCloth = "BulletHitCloth";
const string    BulletHitDefault = "BulletHitDefault";
const string    BulletHitDirt = "BulletHitDirt";
const string    BulletHitMetal = "BulletHitMetal";
const string    BulletHitMoney = "BulletHitMoney";
const string    BulletHitPaper = "BulletHitPaper";
const string    BulletHitWood = "BulletHitWood";
const string    ChainsawSmoke = "CSW";
const string    ClothHit = "CL_H";
const string    CloudDissolve = "DISS";
const string    DestroyCloth = "DestroyCloth";
const string    DestroyDefault = "DestroyDefault";
const string    DestroyGlass = "DestroyGlass";
const string    DestroyMetal = "DestroyMetal";
const string    DestroyPaper = "DestroyPaper";
const string    DestroyWood = "DestroyWood";
const string    Dig = "DIG";
const string    DustTrail = "TR_D";
const string    Electric = "Electric";
const string    Explosion = "EXP";
const string    Fire = "FIRE";
const string    FireNodeTrailAir = "FNDTRA";
const string    FireNodeTrailGround = "FNDTRG";
const string    FireTrail = "TR_F";
const string    Gib = "GIB";
const string    GlassParticles = "G_P";
const string    GrenadeDud = "GR_D";
const string    ImpactDefault = "ImpactDefault";
const string    ImpactPaper = "ImpactPaper";
const string    ItemGleam = "GLM";
const string    MeleeHitBlunt = "HIT_B";
const string    MeleeHitSharp = "HIT_S";
const string    MeleeHitUnarmed = "HIT_U";
const string    PaperDestroyed = "PPR_D";
const string    PlayerBurned = "PLRB";
const string    PlayerFootstep = "F_S";
const string    PlayerLandFull = "H_T";
const string    Smack = "Smack";
const string    SmokeTrail = "TR_S";
const string    Sparks = "S_P";
const string    Steam = "STM";
const string    WaterSplash = "WS";
const string    WoodParticles = "W_P";

string particle = "FIRE";
Vector2 areaOffset = new Vector2(20, 0);

float escalar = 2.0f;

//We use this to get the points in a line
//https://stackoverflow.com/a/34142336/11490425
public class Line {
	public Vector2 p1, p2;

	public Line(Vector2 p1, Vector2 p2) {
		this.p1 = p1;
		this.p2 = p2;
	}

	//this will return a Point array of "quantity" points evenly spaced between the two endpoints (inclusive). 
	public Vector2[] getPoints(ushort quantity) {
		var points = new Vector2[quantity];
		float ydiff = p2.Y - p1.Y, xdiff = p2.X - p1.X;
		double slope = (double)(p2.Y - p1.Y) / (p2.X - p1.X);
		double x, y;

		--quantity;

		for (double i = 0; i < quantity; i++) {
			y = slope == 0 ? 0 : ydiff * (i / quantity);
			x = slope == 0 ? xdiff * (i / quantity) : y / slope;
			points[(int)i] = new Vector2((int)Math.Round(x) + p1.X, (int)Math.Round(y) + p1.Y);
		}

		points[quantity] = p2;
		return points;
	}
}


//propierties
List<Line> lineList = new List<Line>();
List<Vector2> pointsList = new List<Vector2>();
int pointTracker = -1;
bool allLinesHaveBeenAdded = false;

//methods
public void Animate(TriggerArgs args){
	if (pointsList.Count == 0 && allLinesHaveBeenAdded) {
		//This is the first run of Animate
		//Calculate all points from the lineList and add them into pointsList
		foreach(Line line in lineList){
			Vector2[] points = line.getPoints(10);
			foreach(Vector2 point in points){
				pointsList.Add(point);
			}
		}

		//Reset the point tracker
		pointTracker=-1;
	}

	pointTracker++;
	
	if(pointTracker >= pointsList.Count){
		//Clear the counters
		pointTracker = -1;
		pointsList = new List<Vector2>();
		lineList = new List<Line>();
	} else {
		Game.PlayEffect(particle, pointsList[pointTracker]);
	}


}

public void OnStartup() {
	m_playerMeleeActionEvent = Events.PlayerMeleeActionCallback.Start(OnPlayerMeleeAction);
	m_userMessageCallback = Events.UserMessageCallback.Start(OnUserMessage);
}

public void OnPlayerMeleeAction(IPlayer plr, PlayerMeleeHitArg[] args) {
	//Punch + ALT
	if(plr.IsMeleeAttacking == true & plr.IsWalking == true){
		Vector2 plrpos = plr.GetWorldPosition();
		Game.ShowChatMessage("Effect triggered...", Color.Green);
		Game.ShowChatMessage("(" + plrpos.X + " ; " + plrpos.Y + ")");
		Game.ShowChatMessage(".");

		//Game.PlayEffect(particle, plrpos);

		//simple middle points
		Vector2 upperMiddle = new Vector2(0f * escalar, 31f * escalar);
		Vector2 rightMiddle = new Vector2(26.8f * escalar, -15f * escalar);
		Vector2 leftMiddle  = new Vector2(-26.8f * escalar, -15f * escalar);

		//corners
		Vector2 rightCorner = new Vector2(53f * escalar, 31f * escalar);
		Vector2 lowerCorner = new Vector2(0f * escalar, -60.5f * escalar);
		Vector2 leftCorner  = new Vector2(-53f * escalar, 31f * escalar);
		
		//Inner middle points
		Vector2 upperRightMiddle = new Vector2(26.8f * escalar, 16f * escalar);
		Vector2 lowerMiddle      = new Vector2(0f * escalar, -30.5f * escalar);
		Vector2 upperLeftMiddle  = new Vector2(-26.8f * escalar, 16f * escalar);

		//Draw the funky triangle
		//First three lines
		//We use an empty offset on these lines because they come from the player direct's location
		lineList.Add(calculateLine(plrpos, new Vector2(0f, 0f), upperMiddle));
		lineList.Add(calculateLine(plrpos, new Vector2(0f, 0f), rightMiddle));
		lineList.Add(calculateLine(plrpos, new Vector2(0f, 0f), leftMiddle));


		//Border lines
		lineList.Add(calculateLine(plrpos, upperMiddle, rightCorner));
		lineList.Add(calculateLine(plrpos, upperMiddle, leftCorner));

		lineList.Add(calculateLine(plrpos, rightMiddle, rightCorner));
		lineList.Add(calculateLine(plrpos, rightMiddle, lowerCorner));

		lineList.Add(calculateLine(plrpos, leftMiddle, lowerCorner));
		lineList.Add(calculateLine(plrpos, leftMiddle, leftCorner));


		//inner middle lines
		lineList.Add(calculateLine(plrpos, rightCorner, upperRightMiddle));
		lineList.Add(calculateLine(plrpos, lowerCorner, lowerMiddle));
		lineList.Add(calculateLine(plrpos, leftCorner, upperLeftMiddle));


		//Inner square
		lineList.Add(calculateLine(plrpos, upperMiddle, upperRightMiddle));
		lineList.Add(calculateLine(plrpos, upperMiddle, upperLeftMiddle));

		lineList.Add(calculateLine(plrpos, rightMiddle, upperRightMiddle));
		lineList.Add(calculateLine(plrpos, rightMiddle, lowerMiddle));

		lineList.Add(calculateLine(plrpos, leftMiddle, lowerMiddle));
		lineList.Add(calculateLine(plrpos, leftMiddle, upperLeftMiddle));
		
		allLinesHaveBeenAdded = true;
		startTimer(1, (lineList.Count * 10) + 1, "Animate");
		//Animate();
	}
}


public Line calculateLine(Vector2 plrpos, Vector2 startCoordinates, Vector2 endCoordinates){
	
	//create a line between startCoordinates and endCoordinates, using prlpos as the reference point
	Line line = new Line(
		new Vector2(plrpos.X + startCoordinates.X, plrpos.Y + startCoordinates.Y), 
		new Vector2(plrpos.X + endCoordinates.X, plrpos.Y + endCoordinates.Y)
	);

	return line;
}

public void startTimer(int timerSpeed, int skillLength, string functionNameCallback){
	IObjectTimerTrigger timer = (IObjectTimerTrigger)Game.CreateObject("TimerTrigger");
	timer.SetIntervalTime(timerSpeed);
	timer.SetRepeatCount(skillLength);
	timer.SetScriptMethod(functionNameCallback);
	timer.Trigger();
}

/*
//This function can't take any arguments because it's called by a timer, and timers can't pass parameters.
public void drawPoints(TriggerArgs args){
	if(pointTracker < points.Length){
		Game.PlayEffect(particle, points[pointTracker]);
		pointTracker++;
	} else {
		//break the cycle
		//allow another line to begin being drawn
		drawerIsBusy = false;
		pointTracker = 0;
	}
	
}
*/

public void OnUserMessage(UserMessageCallbackArgs args) {

	if (args.IsCommand){
		string[] a = args.CommandArguments.Split();
		if(args.Command == "P"){
			particle = a[0];
			Game.ShowChatMessage("Effect set to \"" + particle + "\"", Color.Green);
		} 

		if (args.Command == "L") {
			areaOffset.X = (float)Convert.ToInt32(a[0]);
			areaOffset.Y = (float)Convert.ToInt32(a[1]);
			Game.ShowChatMessage("Offset set to \"" + areaOffset.X + " " + areaOffset.Y + "\"", Color.Green);
		}

	}
}