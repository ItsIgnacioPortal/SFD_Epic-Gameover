Events.PlayerMeleeActionCallback m_playerMeleeActionEvent = null;
Events.UserMessageCallback m_userMessageCallback = null;

const string    AcidSplash = "ACS";
const string    Block = "Block";
const string    Blood = "BLD";
const string    BloodTrail = "TR_B";
const string    BulletHit = "BulletHit";
const string    BulletHitCloth = "BulletHitCloth";
const string    BulletHitDefault = "BulletHitDefault";
const string    BulletHitDirt = "BulletHitDirt";
const string    BulletHitMetal = "BulletHitMetal";
const string    BulletHitMoney = "BulletHitMoney";
const string    BulletHitPaper = "BulletHitPaper";
const string    BulletHitWood = "BulletHitWood";
const string    ChainsawSmoke = "CSW";
const string    ClothHit = "CL_H";
const string    CloudDissolve = "DISS";
const string    DestroyCloth = "DestroyCloth";
const string    DestroyDefault = "DestroyDefault";
const string    DestroyGlass = "DestroyGlass";
const string    DestroyMetal = "DestroyMetal";
const string    DestroyPaper = "DestroyPaper";
const string    DestroyWood = "DestroyWood";
const string    Dig = "DIG";
const string    DustTrail = "TR_D";
const string    Electric = "Electric";
const string    Explosion = "EXP";
const string    Fire = "FIRE";
const string    FireNodeTrailAir = "FNDTRA";
const string    FireNodeTrailGround = "FNDTRG";
const string    FireTrail = "TR_F";
const string    Gib = "GIB";
const string    GlassParticles = "G_P";
const string    GrenadeDud = "GR_D";
const string    ImpactDefault = "ImpactDefault";
const string    ImpactPaper = "ImpactPaper";
const string    ItemGleam = "GLM";
const string    MeleeHitBlunt = "HIT_B";
const string    MeleeHitSharp = "HIT_S";
const string    MeleeHitUnarmed = "HIT_U";
const string    PaperDestroyed = "PPR_D";
const string    PlayerBurned = "PLRB";
const string    PlayerFootstep = "F_S";
const string    PlayerLandFull = "H_T";
const string    Smack = "Smack";
const string    SmokeTrail = "TR_S";
const string    Sparks = "S_P";
const string    Steam = "STM";
const string    WaterSplash = "WS";
const string    WoodParticles = "W_P";

Color tealGreen = new Color(102, 255, 51);


bool roundStartMessageIsMuted = false;
string particle = "FIRE";
float escalar = 2.0f;
string animation = "triangle";


//We use this to get the points in a line
//https://stackoverflow.com/a/34142336/11490425
public class Line {
	public Vector2 p1, p2;

	public Line(Vector2 p1, Vector2 p2) {
		this.p1 = p1;
		this.p2 = p2;
	}

	//this will return a Point array of "quantity" points evenly spaced between the two endpoints (inclusive). 
	public Vector2[] getPoints(ushort quantity) {
		var points = new Vector2[quantity];
		float ydiff = p2.Y - p1.Y, xdiff = p2.X - p1.X;
		double slope = (double)(p2.Y - p1.Y) / (p2.X - p1.X);
		double x, y;

		--quantity;

		for (double i = 0; i < quantity; i++) {
			y = slope == 0 ? 0 : ydiff * (i / quantity);
			x = slope == 0 ? xdiff * (i / quantity) : y / slope;
			points[(int)i] = new Vector2((int)Math.Round(x) + p1.X, (int)Math.Round(y) + p1.Y);
		}

		points[quantity] = p2;
		return points;
	}
}


//Every line is in a group. This matrix stores those groups of lines
List<List<Line>> groupsListMatrix = new List<List<Line>>();

//This is the simple list that stores a list of points for Animate() to draw
List<Vector2> pointsList = new List<Vector2>();

//A global tracker because timers can't pass parameters
int pointTracker = -1;

//A switch to prevent the pointsList from being overwritten while it's being drawn 
bool allLinesHaveBeenAdded = false;

//This is the actual function that draws the animation.
public void Animate(TriggerArgs args){
	if (pointsList.Count == 0 && allLinesHaveBeenAdded) {
		//This is the first run of Animate
		//Calculate all points from the lineList and add them into pointsList

		for(ushort groupCounter = 0; groupCounter < groupsListMatrix.Count; groupCounter++){
			List<List<Vector2>> middlemanMatrix = new List<List<Vector2>>();
			
			for(ushort lineCounter = 0; lineCounter < groupsListMatrix[groupCounter].Count; lineCounter++){
				Vector2[] points = groupsListMatrix[groupCounter][lineCounter].getPoints(10);
				middlemanMatrix.Add(new List<Vector2>());
				
				for(ushort pointCounter = 0; pointCounter < points.Length; pointCounter++){
					middlemanMatrix[lineCounter].Add(points[pointCounter]);
				}
			}
			//transpose middlemanMatrix
			List<List<Vector2>> transposedMiddlemanMatrix = Transpose(middlemanMatrix);

			//Add the points to pointsList
			for(ushort column = 0; column < transposedMiddlemanMatrix.Count; column++){
				for(ushort row = 0; row < transposedMiddlemanMatrix[column].Count; row++){
					pointsList.Add(transposedMiddlemanMatrix[column][row]);
				}
			}

		}

		

		//Reset the point tracker
		pointTracker=-1;
	}

	pointTracker++;
	
	if(pointTracker >= pointsList.Count){
		//Clear the counters
		groupsListMatrix = new List<List<Line>>();
		pointsList = new List<Vector2>();
		pointTracker = -1;
	} else {
		Game.PlayEffect(particle, pointsList[pointTracker]);
	}


}


//This function transposes a List<List<Vector2>> matrix
//https://stackoverflow.com/a/13586633/11490425
public static List<List<Vector2>> Transpose<Vector2>(List<List<Vector2>> lists){
	var longest = lists.Any() ? lists.Max(l => l.Count) : 0;
	List<List<Vector2>> outer = new List<List<Vector2>>(longest);
	for (int i = 0; i < longest; i++)
		outer.Add(new List<Vector2>(lists.Count));
	for (int j = 0; j < lists.Count; j++)
		for (int i = 0; i < longest; i++)
			outer[i].Add(lists[j][i]);
	return outer;
}


public void OnStartup() {
	m_playerMeleeActionEvent = Events.PlayerMeleeActionCallback.Start(OnPlayerMeleeAction);
	m_userMessageCallback = Events.UserMessageCallback.Start(OnUserMessage);

	//Load local storage
	loadLocalStorage();

	if(!roundStartMessageIsMuted){
		Game.ShowChatMessage("Epic-Gameover: Run \"/ego help\" for config options.", Color.Green);
	}
}

public void OnPlayerMeleeAction(IPlayer plr, PlayerMeleeHitArg[] args) {
	//Punch + ALT
	if(plr.IsMeleeAttacking == true & plr.IsWalking == true){
		Vector2 plrpos = plr.GetWorldPosition();
		
		switch(animation){
			case "triangle":
				drawTriangle(plrpos);
			break;

			case "pentagram":
				drawPentagram(plrpos);
			break;
		}
	}
}

//See: triangle.jpg
public void drawTriangle(Vector2 plrpos){

	//These "magical numbers" where extracted from a Geogebra model of triangle.jpg
	//simple middle points
	Vector2 upperMiddle = new Vector2(0f * escalar, 31f * escalar);
	Vector2 rightMiddle = new Vector2(26.8f * escalar, -15f * escalar);
	Vector2 leftMiddle  = new Vector2(-26.8f * escalar, -15f * escalar);

	//corners
	Vector2 rightCorner = new Vector2(53f * escalar, 31f * escalar);
	Vector2 lowerCorner = new Vector2(0f * escalar, -60.5f * escalar);
	Vector2 leftCorner  = new Vector2(-53f * escalar, 31f * escalar);
	
	//Inner middle points
	Vector2 upperRightMiddle = new Vector2(26.8f * escalar, 16f * escalar);
	Vector2 lowerMiddle      = new Vector2(0f * escalar, -30.5f * escalar);
	Vector2 upperLeftMiddle  = new Vector2(-26.8f * escalar, 16f * escalar);

	//Draw the funky triangle
	//First three lines
	//We use an empty offset on these lines because they come from the player direct's location
	groupsListMatrix.Add(new List<Line>(){
		calculateLine(plrpos, new Vector2(0f, 0f), upperMiddle),
		calculateLine(plrpos, new Vector2(0f, 0f), rightMiddle),
		calculateLine(plrpos, new Vector2(0f, 0f), leftMiddle),
	});

	
	//Border lines
	groupsListMatrix.Add(new List<Line>(){
		calculateLine(plrpos, upperMiddle, rightCorner),
		calculateLine(plrpos, upperMiddle, leftCorner),

		calculateLine(plrpos, rightMiddle, rightCorner),
		calculateLine(plrpos, rightMiddle, lowerCorner),

		calculateLine(plrpos, leftMiddle, lowerCorner),
		calculateLine(plrpos, leftMiddle, leftCorner)
	});

	
	//inner middle lines
	groupsListMatrix.Add(new List<Line>(){
		calculateLine(plrpos, rightCorner, upperRightMiddle),
		calculateLine(plrpos, lowerCorner, lowerMiddle),
		calculateLine(plrpos, leftCorner, upperLeftMiddle),
	});


	//Inner square
	groupsListMatrix.Add(new List<Line>(){
		calculateLine(plrpos, upperMiddle, upperRightMiddle),
		calculateLine(plrpos, upperMiddle, upperLeftMiddle),

		calculateLine(plrpos, rightMiddle, upperRightMiddle),
		calculateLine(plrpos, rightMiddle, lowerMiddle),

		calculateLine(plrpos, leftMiddle, lowerMiddle),
		calculateLine(plrpos, leftMiddle, upperLeftMiddle),
	});
		
	allLinesHaveBeenAdded = true;

	//I use three timers to make the animation faster
	//Formula:
	//1, (totalNumberOfLines/numberOfTimers * 10) + 1, "Animate"
	startTimer(1, (6 * 10) + 1, "Animate");
	startTimer(1, (6 * 10) + 1, "Animate");
	startTimer(1, (6 * 10) + 1, "Animate");
}


//See pentagram.jpg
public void drawPentagram(Vector2 plrpos){


	//I made the geogebra model too small :P
	float escalarLocal = escalar + 2.128f;

	//middle points
	Vector2 middleUpperRight = new Vector2(6f * escalarLocal, 8f * escalarLocal);
	Vector2 middleRight      = new Vector2(9.7f * escalarLocal, -3.2f * escalarLocal);
	Vector2 middleBottom     = new Vector2(0f * escalarLocal, -10f * escalarLocal);
	Vector2 middleLeft       = new Vector2(-9.7f * escalarLocal, -3.2f * escalarLocal);
	Vector2 middleUpperLeft  = new Vector2(-6f * escalarLocal, 8f * escalarLocal);

	//Corners
	Vector2 topCorner         = new Vector2(0f * escalarLocal, 26.5f * escalarLocal);
	Vector2 rightCorner       = new Vector2(24.9f * escalarLocal, 8f * escalarLocal);
	Vector2 bottomRightCorner = new Vector2(15.3f * escalarLocal, -21.3f * escalarLocal);
	Vector2 bottomLeftCorner  = new Vector2(-15.3f * escalarLocal, -21.3f * escalarLocal);
	Vector2 leftCorner        = new Vector2(-24.9f * escalarLocal, 8f * escalarLocal);

	//I won't even try to explain this. You'll have to see it in-game
	groupsListMatrix.Add(new List<Line>(){
		calculateLine(plrpos, middleUpperRight, topCorner),
		calculateLine(plrpos, middleUpperRight, bottomRightCorner),

		calculateLine(plrpos, middleRight, rightCorner),
		calculateLine(plrpos, middleRight, bottomLeftCorner),

		calculateLine(plrpos, middleBottom, bottomRightCorner),
		calculateLine(plrpos, middleBottom, leftCorner),

		calculateLine(plrpos, middleLeft, topCorner),
		calculateLine(plrpos, middleLeft, bottomLeftCorner),

		calculateLine(plrpos, middleUpperLeft, rightCorner),
		calculateLine(plrpos, middleUpperLeft, leftCorner)
	});

	allLinesHaveBeenAdded = true;

	//I use three timers to make the animation faster
	//Formula:
	//1, (totalNumberOfLines/numberOfTimers * 10) + 1, "Animate"
	startTimer(1, (5 * 10) + 1, "Animate");
	startTimer(1, (5 * 10) + 1, "Animate");
}


//This creates a line between startCoordinates and endCoordinates using plrpos as the center of the plane
public Line calculateLine(Vector2 plrpos, Vector2 startCoordinates, Vector2 endCoordinates){
	
	//create a line between startCoordinates and endCoordinates, using prlpos as the reference point
	Line line = new Line(
		new Vector2(plrpos.X + startCoordinates.X, plrpos.Y + startCoordinates.Y), 
		new Vector2(plrpos.X + endCoordinates.X, plrpos.Y + endCoordinates.Y)
	);

	return line;
}

public void startTimer(int timerSpeed, int skillLength, string functionNameCallback){
	IObjectTimerTrigger timer = (IObjectTimerTrigger)Game.CreateObject("TimerTrigger");
	timer.SetIntervalTime(timerSpeed);
	timer.SetRepeatCount(skillLength);
	timer.SetScriptMethod(functionNameCallback);
	timer.Trigger();
}

public void OnUserMessage(UserMessageCallbackArgs args) {

	if (args.IsCommand){
		if(args.Command == "EGO"){
			string[] a = args.CommandArguments.Split();
			switch(a[0]){
				case "help":
					Game.ShowChatMessage("\"/ego particle PARTICLE-NAME\" to set the particle that the animations will use.", tealGreen);
					Game.ShowChatMessage("\"/ego animation ANIMATION-NAME\" to select an animation.", tealGreen);
					Game.ShowChatMessage("\"/ego scale NUMBER\" to change the scale of the animations.", tealGreen);
					Game.ShowChatMessage("\"/ego message\" to toggle the round-start message.", tealGreen);
					Game.ShowChatMessage("\"/ego settings\" to view the current settings.", tealGreen);
					Game.ShowChatMessage("\"/ego reset\" to reset the settings to default.", tealGreen);
				break;

				case "particle":
					particle = a[1];
					Game.ShowChatMessage("EGO: particle set to \"" + particle + "\"", Color.Green);
				break;

				case "scale":
					try {
						//if the user input is a greater than 0 valid float...
						if (float.Parse(a[1]) > 0f){
							//set it
							escalar = float.Parse(a[1]);
						}

						Game.ShowChatMessage("EGO: Scale set to \"" + escalar + "\"", Color.Green);

					} catch {
						Game.ShowChatMessage("EGO: Scale must be a positive number!", Color.Red);
					}
					
				break;

				case "animation":
					a[1] = a[1].ToLower();

					if(
						a[1] == "pentagram" ||
						a[1] == "triangle" ||
					 	a[1] == "cube"
					){

						animation = a[1];
					
					} else {
						Game.ShowChatMessage("EGO: Invalid animation.", Color.Red);
						Game.ShowChatMessage("The available animations are: ", Color.Green);
						Game.ShowChatMessage("- Pentagram", tealGreen);
						Game.ShowChatMessage("- Triangle", tealGreen);
						Game.ShowChatMessage("- Cube", tealGreen);
					}
					

				break;

				case "message":
					//change settings
					roundStartMessageIsMuted = !roundStartMessageIsMuted;
					//add change to storage
					Game.LocalStorage.SetItem("roundStartMessageIsMuted", roundStartMessageIsMuted);

					Game.ShowChatMessage("Neo-vs-Matrix: The round start reminder has been toggled.", Color.Green);
				break;

				case "settings":
					Game.ShowChatMessage("Scale: " + escalar.ToString(), tealGreen);
					Game.ShowChatMessage("Particle: " + particle, tealGreen);
					Game.ShowChatMessage("Animation: " + animation, tealGreen);
					Game.ShowChatMessage("Message: " + roundStartMessageIsMuted.ToString(), tealGreen);

				break;

				case "reset":
					resetSettings();
					Game.ShowChatMessage("EGO: The settings have been reset to default.", Color.Green);
				break;
			}
		}
	}
}


public void loadLocalStorage(){
	//no need to check that ALL settings load correctly. Checking the first one will suffice.
	if (!Game.LocalStorage.TryGetItemFloat("escalar", out escalar)){ 
		resetSettings();
	} else {
		Game.LocalStorage.TryGetItemString("particle", out particle);
		Game.LocalStorage.TryGetItemBool("roundStartMessageIsMuted", out roundStartMessageIsMuted);
		Game.LocalStorage.TryGetItemString("animation", out animation);


		//escalar should be a positive number
		//particle shouldn't be an empty string
		if(
			escalar < 0 ||
			particle == ""	
		){
			resetSettings();
			Game.ShowChatMessage("EGO: The configuration contains invalid values; It may have been tampered with. The configuration has been reset to default.", Color.Red);
		}
	}
}


//reset local storage settings
public void resetSettings(){
	float escalar = 2f;
	string particle = "FIRE";
	bool roundStartMessageIsMuted = false;
	string animation = "triangle";
	
	Game.LocalStorage.SetItem("escalar", escalar);
	Game.LocalStorage.SetItem("particle", particle);
	Game.LocalStorage.SetItem("roundStartMessageIsMuted", roundStartMessageIsMuted);
	Game.LocalStorage.SetItem("animation", animation);

	loadLocalStorage();
}